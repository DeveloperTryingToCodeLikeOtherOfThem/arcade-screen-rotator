{"entries":[{"timestamp":1761587181203,"editorVersion":"2.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":84,"length1":105,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":168,"length1":45,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":197,"length1":44,"diffs":[[1,""]]},{"start1":229,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"},{"type":"added","filename":"tansform.ts","value":"//% weight=0 color=#b8860b icon=\"\\uf021\" block=\"Screen Transforms\"\n//% advanced=true\n\n// ref from arcade-turtle-logo \nnamespace screenRotator {\n    // Number of times the scaled image has been doubled.\n    // Scaled image is used for sampling when rotating image.\n    const NUM_SCALES: number = 1;\n\n    let _enabled = true\n\n    // Container of state information for rotated sprites\n    let _spritesWithRotations: Array<SpriteWithRotation> = [];\n\n    class SpriteWithRotation {\n        private _spriteId: number;\n        private _currRotation: number;\n        private _origImage: Image;\n        private _scaledImage: Image;\n\n        constructor(sprite: Sprite, angle: number = 0) {\n            this._spriteId = sprite.id;\n            this._currRotation = angle;\n            this._origImage = sprite.image.clone();\n            this._scaledImage = scale2x(sprite.image);\n        }   // constructor()\n\n        get id(): number {\n            return this._spriteId;\n        }   // get id()\n\n        get image(): Image {\n            return this._origImage;\n        }   // get image()\n\n        get rotation(): number {\n            return this._currRotation;\n        }   // get rotation()\n\n        set rotation(angle: number) {\n            this._currRotation = angle;\n        }   // set rotation()\n\n        get scaledImage(): Image {\n            return this._scaledImage;\n        }   // get scaledImage()\n    }   // class SpriteWithRotation\n\n    class Coordinate {\n        private _x: number;\n        private _y: number;\n\n        constructor(x: number, y: number) {\n            this._x = x;\n            this._y = y;\n        }   // constructor()\n\n        public get x() {\n            return this._x;\n        }   // get x()\n\n        public get y() {\n            return this._y;\n        }   // get y()\n    }   // class Coordinate\n\n    class Vector {\n        private _mag: number;\n        private _dir: number;\n\n        constructor(magnitude: number, direction: number) {\n            this._mag = magnitude;\n            this._dir = direction;\n        }   // constructor()\n\n        public get direction() {\n            return this._dir;\n        }   // get direction()\n\n        public get magnitude() {\n            return this._mag;\n        }   // get magnitude()\n    }   // class Vector\n\n\n    /**\n     * Increment the rotation of a sprite.\n     * The sprite's image will be updated with the new rotation.\n     * Angle is in degrees.\n     * Positive change rotates clockwise; negative change rotates counterclockwise.\n     */\n    //% blockId=transform_change_rotation\n    //% block=\"change rotation of %sprite(mySprite) by %angleChange degrees\"\n    //% sprite.shadow=\"variables_get\" angleChange.defl=0\n    export function changeRotation(sprite: Sprite, angleChange: number): void {\n        if (_enabled) {\n            if (!_spritesWithRotations[sprite.id]) {\n                _spritesWithRotations[sprite.id] = new SpriteWithRotation(sprite, 0);\n            }   // if ( ! _spritesWithRotations[sprite.id] )\n\n            rotateSprite(sprite, _spritesWithRotations[sprite.id].rotation + angleChange);\n        }\n    }   // changeRotation()\n\n    /**\n     * Get the current rotation angle for a sprite in degrees.\n     */\n    //% blockId=transform_get_rotation\n    //% block=\"%sprite(mySprite) rotation\"\n    //% sprite.shadow=\"variables_get\"\n    export function getRotation(sprite: Sprite): number {\n        if (!_spritesWithRotations[sprite.id]) {\n            return 0;\n        } else {\n            return _spritesWithRotations[sprite.id].rotation;\n        }   // if ( ! SpriteWithRotations[sprite.id])\n    }   // getRotation()\n\n    /**\n     * Rotate a sprite to a specific angle.\n     * The sprite's image will be updated to the rotated image.\n     * Angle is in degrees.\n     * Positive change rotates clockwise; negative change rotates counterclockwise.\n     */\n    //% blockId=transform_rotate_sprite\n    //% block=\"set rotation of %sprite(mySprite) to %angle degrees\"\n    //% sprite.shadow=\"variables_get\" angle.defl=0\n    export function rotateSprite(sprite: Sprite, angle: number): void {\n        if (_enabled) {\n            if (!_spritesWithRotations[sprite.id]) {\n                _spritesWithRotations[sprite.id] = new SpriteWithRotation(sprite, 0);\n            }   // if ( ! _spritesWithRotations[sprite.id] )\n\n            _spritesWithRotations[sprite.id].rotation = angle;\n            sprite.setImage(rotate(_spritesWithRotations[sprite.id], angle * control.eventContext().deltaTime));\n        }\n    }   // rotateSprite()\n\n    function rotate(sprite: SpriteWithRotation, angle: number): Image {\n        // Normalize angle.\n        angle %= 360;\n        if (angle < 0) {\n            angle += 360;\n        }   // if (angle < 0)\n\n        // Reflections not needing actual rotation.\n        let toReturn: Image = null;\n        let x: number = 0;\n        let y: number = 0;\n\n        toReturn = image.create(sprite.image.width, sprite.image.height);\n        const rads: number = Math.PI * angle / 180;\n        let center: Coordinate = new Coordinate(toReturn.width >> 1, toReturn.height >> 1);\n\n        for (x = 0; x < toReturn.width; x++) {\n            for (y = 0; y < toReturn.height; y++) {\n                let currVector: Vector = new Vector(\n                    Math.sqrt((x - center.x) ** 2 + (y - center.y) ** 2),\n                    Math.atan2(y - center.y, x - center.x)\n                );\n\n                let rotVector: Vector = new Vector(\n                    currVector.magnitude,\n                    currVector.direction - rads\n                );\n\n                let scaledCoord: Coordinate = new Coordinate(\n                    Math.round((center.x << NUM_SCALES) + (rotVector.magnitude << NUM_SCALES) * Math.cos(rotVector.direction)),\n                    Math.round((center.y << NUM_SCALES) + (rotVector.magnitude << NUM_SCALES) * Math.sin(rotVector.direction))\n                );\n\n                if (scaledCoord.x >= 0 && scaledCoord.x < sprite.scaledImage.width &&\n                    scaledCoord.y >= 0 && scaledCoord.y < sprite.scaledImage.height) {\n                    toReturn.setPixel(x, y, sprite.scaledImage.getPixel(scaledCoord.x, scaledCoord.y));\n                }   // scaledCoord within scaledImage bounds\n            }   // for ( y )\n        }   // for ( x )\n        return toReturn;\n    }   // rotateImage()\n\n\n    /**\n     * Smoothly doubles the size of an image.\n     */\n    // Implementation of Scale2X variation of Eric's Pixel Expansion (EPX) algorithm.\n    //% blockId=transform_scale2x\n    //% block=\"double size of|image %original=screen_image_picker\"\n    export function scale2x(original: Image): Image {\n        // Double the size of the original.\n        let toReturn: Image = image.create(original.width << 1, original.height << 1);\n\n        for (let x: number = 0; x < original.width; x++) {\n            for (let y: number = 0; y < original.height; y++) {\n                // From original image:\n                // .a.\n                // cpb\n                // .d.\n                const p: color = original.getPixel(x, y);\n                const a: color = original.getPixel(x, y - 1);\n                const b: color = original.getPixel(x + 1, y);\n                const c: color = original.getPixel(x - 1, y);\n                const d: color = original.getPixel(x, y + 1);\n\n                // In scaled image:\n                // 12\n                // 34\n                let one: Coordinate = new Coordinate(x << 1, y << 1);\n                let two: Coordinate = new Coordinate(one.x + 1, one.y);\n                let three: Coordinate = new Coordinate(one.x, one.y + 1);\n                let four: Coordinate = new Coordinate(one.x + 1, one.y + 1);\n\n                // 1=P; 2=P; 3=P; 4=P;\n                // IF C== A AND C!= D AND A!= B => 1 = A\n                // IF A== B AND A!= C AND B!= D => 2 = B\n                // IF D== C AND D!= B AND C!= A => 3 = C\n                // IF B== D AND B!= A AND D!= C => 4 = D\n                toReturn.setPixel(one.x, one.y, p);\n                toReturn.setPixel(two.x, two.y, p);\n                toReturn.setPixel(three.x, three.y, p);\n                toReturn.setPixel(four.x, four.y, p);\n\n                if (c == a && c != d && a != b) {\n                    toReturn.setPixel(one.x, one.y, a);\n                }   // if ( c == a ...\n                if (a == b && a != c && b != d) {\n                    toReturn.setPixel(two.x, two.y, b);\n                }   // if ( a == b ...\n                if (d == c && d != b && c != a) {\n                    toReturn.setPixel(three.x, three.y, c);\n                }   // if ( d == c ...\n                if (b == d && b != a && d != c) {\n                    toReturn.setPixel(four.x, four.y, d);\n                }   // if ( b == d ...\n            }   // for ( y )\n        }   // for ( x )\n        return toReturn;\n    }   // scale2x()\n\n    //% blockId=rotate_screen_enabled block=\"rotate screen enabled %enabled=toggleOnOff\"\n    //% enabled.defl=true weight=30\n    /** \n     * Controls turn on or off the screen rotation\n     */\n    export function rotateScreenEnabled(enabled: boolean) {\n        _enabled = enabled\n    }\n}   // namespace transformScreen\n"}]}],"snapshots":[{"timestamp":1761587181202,"editorVersion":"2.0.61","text":{"main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-screen-rotator\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1761587282650}